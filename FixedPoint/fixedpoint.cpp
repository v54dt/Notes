// NOTE: This code was generated by AI and has not been verified or tested.
// It is for reference purposes only and should NOT be used in production or
// testing environments.

#include "fixedpoint.h"

#include <algorithm>
#include <cmath>
#include <cstring>
#include <stdexcept>

// Check for C++20 support
#if __cplusplus >= 202002L
#include <format>
#define HAS_STD_FORMAT 1
#else
#include <iomanip>
#include <sstream>
#define HAS_STD_FORMAT 0
#endif

namespace fputil {

namespace internal {
// Convert FixedPoint to fpm::fixed (optimized)
inline fpm_type to_fpm(const FixedPoint& fp) {
  if (fp.precision == 0) {
    return fpm_type{static_cast<double>(fp.value)};
  }

  // Use fast power of 10 lookup
  int64_t divisor = fast_pow10(fp.precision);
  if (divisor == 0) {
    // Fallback for large precision values
    double value = fp.value;
    for (unsigned int i = 0; i < fp.precision; ++i) {
      value /= 10.0;
    }
    return fpm_type{value};
  }

  return fpm_type{static_cast<double>(fp.value) / divisor};
}

// Convert fpm::fixed to FixedPoint with specified precision
inline FixedPoint from_fpm(const fpm_type& value, unsigned int precision) {
  double val = static_cast<double>(value);
  int64_t multiplier = fast_pow10(precision);

  if (multiplier == 0) {
    // Fallback for large precision
    for (unsigned int i = 0; i < precision; ++i) {
      val *= 10.0;
    }
    return FixedPoint(static_cast<int>(val + 0.5), precision);
  }

  // Fast path with lookup table
  int int_value = static_cast<int>(val * multiplier + (val >= 0 ? 0.5 : -0.5));
  return FixedPoint(int_value, precision);
}

// Normalize two FixedPoint values to have the same precision (optimized)
inline std::pair<FixedPoint, FixedPoint> normalize_precision(
    const FixedPoint& a, const FixedPoint& b) {
  if (a.precision == b.precision) return {a, b};

  if (a.precision < b.precision) {
    int64_t scale = fast_pow10(b.precision - a.precision);
    return {FixedPoint(a.value * scale, b.precision), b};
  } else {
    int64_t scale = fast_pow10(a.precision - b.precision);
    return {a, FixedPoint(b.value * scale, a.precision)};
  }
}


}  // namespace internal

// Convert FixedPoint to string (optimized version)
std::string to_string(const FixedPoint& fp) {
  if (fp.precision == 0) {
    char buffer[16];
    int len = sprintf(buffer, "%d", fp.value);
    return std::string(buffer, len);
  }

  char buffer[32];
  int divisor = internal::fast_pow10(fp.precision);
  int integer_part = fp.value / divisor;
  int fractional_part = fp.value % divisor;
  
  if (fractional_part < 0) fractional_part = -fractional_part;
  
  int len = sprintf(buffer, "%d.%0*d", integer_part, fp.precision, fractional_part);
  return std::string(buffer, len);
}

// Convert FixedPoint to string with specified precision
std::string to_string_formatted(const FixedPoint& fp, int precision) {
#if HAS_STD_FORMAT
  return std::format("{:.{}f}", to_double(fp), precision);
#else
  char buffer[64];
  int len = snprintf(buffer, sizeof(buffer), "%.*f", precision, to_double(fp));
  return std::string(buffer, len);
#endif
}

// Convert FixedPoint to double (optimized)
double to_double(const FixedPoint& fp) {
  if (fp.precision == 0) return static_cast<double>(fp.value);
  
  int64_t divisor = internal::fast_pow10(fp.precision);
  return divisor ? static_cast<double>(fp.value) / divisor : fp.value / std::pow(10.0, fp.precision);
}

// Convert FixedPoint to int (optimized)
int to_int(const FixedPoint& fp) {
  if (fp.precision == 0) return fp.value;
  
  int64_t divisor = internal::fast_pow10(fp.precision);
  return divisor ? fp.value / divisor : fp.value / static_cast<int>(std::pow(10, fp.precision));
}

// Create FixedPoint from double (optimized)
FixedPoint from_double(double value, unsigned int precision) {
  precision = std::min(precision, static_cast<unsigned int>(MAX_PRECISION));
  
  int64_t multiplier = internal::fast_pow10(precision);
  double scaled = multiplier ? value * multiplier : value * std::pow(10.0, precision);
  
  return FixedPoint(static_cast<int>(scaled + (scaled >= 0 ? 0.5 : -0.5)), precision);
}

// Create FixedPoint from string (optimized)
FixedPoint from_string(const std::string& str) {
  const char* p = str.c_str();
  bool negative = (*p == '-');
  if (negative || *p == '+') ++p;
  
  int integer_part = 0;
  while (*p >= '0' && *p <= '9') {
    integer_part = integer_part * 10 + (*p++ - '0');
  }
  
  if (*p != '.') {
    return FixedPoint(negative ? -integer_part : integer_part, 0);
  }
  
  ++p; // Skip '.'
  int fractional_part = 0;
  unsigned int precision = 0;
  while (*p >= '0' && *p <= '9') {
    fractional_part = fractional_part * 10 + (*p++ - '0');
    ++precision;
  }
  
  int64_t total = static_cast<int64_t>(integer_part) * internal::fast_pow10(precision) + fractional_part;
  return FixedPoint(negative ? -total : total, precision);
}

// Arithmetic operations (optimized for common precision case)
FixedPoint add(const FixedPoint& a, const FixedPoint& b) {
  if (a.precision == b.precision) {
    // Fast path: same precision
    return FixedPoint(a.value + b.value, a.precision);
  }

  auto [norm_a, norm_b] = internal::normalize_precision(a, b);
  return FixedPoint(norm_a.value + norm_b.value, norm_a.precision);
}

FixedPoint subtract(const FixedPoint& a, const FixedPoint& b) {
  if (a.precision == b.precision) {
    // Fast path: same precision
    return FixedPoint(a.value - b.value, a.precision);
  }

  auto [norm_a, norm_b] = internal::normalize_precision(a, b);
  return FixedPoint(norm_a.value - norm_b.value, norm_a.precision);
}

FixedPoint multiply(const FixedPoint& a, const FixedPoint& b) {
  int64_t result = static_cast<int64_t>(a.value) * b.value;
  unsigned int precision = a.precision + b.precision;

  while (precision > MAX_PRECISION || result > INT32_MAX || result < INT32_MIN) {
    result /= 10;
    precision--;
  }

  return FixedPoint(static_cast<int>(result), precision);
}

FixedPoint divide(const FixedPoint& a, const FixedPoint& b) {
  if (b.value == 0) throw std::domain_error("Division by zero");

  int64_t scaled_a = static_cast<int64_t>(a.value) * internal::fast_pow10(DEFAULT_FRACTIONAL_DIGITS);
  int64_t result = scaled_a / b.value;
  unsigned int precision = a.precision + DEFAULT_FRACTIONAL_DIGITS - b.precision;

  while (result > INT32_MAX || result < INT32_MIN || precision > MAX_PRECISION) {
    result /= 10;
    precision--;
  }

  return FixedPoint(static_cast<int>(result), precision);
}

// Comparison operations (optimized)
bool equals(const FixedPoint& a, const FixedPoint& b) {
  if (a.precision == b.precision) return a.value == b.value;
  if (a.value == 0 && b.value == 0) return true;
  
  auto [norm_a, norm_b] = internal::normalize_precision(a, b);
  return norm_a.value == norm_b.value;
}

bool less_than(const FixedPoint& a, const FixedPoint& b) {
  if (a.precision == b.precision) return a.value < b.value;
  if ((a.value < 0) != (b.value < 0)) return a.value < 0;
  
  auto [norm_a, norm_b] = internal::normalize_precision(a, b);
  return norm_a.value < norm_b.value;
}

bool greater_than(const FixedPoint& a, const FixedPoint& b) {
  if (a.precision == b.precision) return a.value > b.value;
  if ((a.value < 0) != (b.value < 0)) return a.value > 0;
  
  auto [norm_a, norm_b] = internal::normalize_precision(a, b);
  return norm_a.value > norm_b.value;
}
}  // namespace fputil

// Operator overloads
bool operator==(const FixedPoint& a, const FixedPoint& b) {
  return fputil::equals(a, b);
}

bool operator!=(const FixedPoint& a, const FixedPoint& b) {
  return !fputil::equals(a, b);
}

bool operator<(const FixedPoint& a, const FixedPoint& b) {
  return fputil::less_than(a, b);
}

bool operator>(const FixedPoint& a, const FixedPoint& b) {
  return fputil::greater_than(a, b);
}

bool operator<=(const FixedPoint& a, const FixedPoint& b) {
  return !fputil::greater_than(a, b);
}

bool operator>=(const FixedPoint& a, const FixedPoint& b) {
  return !fputil::less_than(a, b);
}

FixedPoint operator+(const FixedPoint& a, const FixedPoint& b) {
  return fputil::add(a, b);
}

FixedPoint operator-(const FixedPoint& a, const FixedPoint& b) {
  return fputil::subtract(a, b);
}

FixedPoint operator*(const FixedPoint& a, const FixedPoint& b) {
  return fputil::multiply(a, b);
}

FixedPoint operator/(const FixedPoint& a, const FixedPoint& b) {
  return fputil::divide(a, b);
}

// Stream operators
std::ostream& operator<<(std::ostream& os, const FixedPoint& fp) {
  os << fputil::to_string(fp);
  return os;
}

std::istream& operator>>(std::istream& is, FixedPoint& fp) {
  std::string str;
  is >> str;
  if (!is.fail()) {
    try {
      fp = fputil::from_string(str);
    } catch (...) {
      is.setstate(std::ios::failbit);
    }
  }
  return is;
}

// Global namespace versions of the three requested functions
std::string to_string(FixedPoint fp) { return fputil::to_string(fp); }

double to_double(FixedPoint fp) { return fputil::to_double(fp); }

int to_int(FixedPoint fp) { return fputil::to_int(fp); }
